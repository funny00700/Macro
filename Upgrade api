-- รอให้ตัวเกมโหลดเสร็จสมบูรณ์ 100% ก่อนที่สคริปต์จะเริ่มทำงาน
if not game:IsLoaded() then
    game.Loaded:Wait()
end

local replicatedstorage = game:GetService("ReplicatedStorage")
local library = loadstring(game:HttpGet('https://raw.githubusercontent.com/ovoch228/depthsoimgui/refs/heads/main/library'))()

-- รอให้โฟลเดอร์ที่จำเป็นโหลดขึ้นมาก่อน
local bytenet = require(replicatedstorage:WaitForChild("Teawork", 10):WaitForChild("Shared"):WaitForChild("Services"):WaitForChild("ByteNetworking"))

local api = {}

function api:Loadout(towers: table)
    if game.PlaceId ~= 98936097545088 then return end

    for i = 1, #towers do
        bytenet.Inventory.EquipTower.invoke({["TowerID"] = towers[i], ["Slot"] = i})
        task.wait(0.5)
    end
end

function api:Map(map: string, modifiers: table)
    if game.PlaceId ~= 98936097545088 then return end
    
    task.wait(1) -- ดีเลย์เล็กน้อยก่อนสร้างห้อง
    bytenet.MatchmakingNew.CreateSingleplayer.invoke({["Gamemode"] = "Standard", ["MapID"] = map, ["Modifiers"] = modifiers})
    
    -- เมื่อกดสร้างห้องแล้ว ให้สคริปต์หยุดรอตรงนี้เลย เพื่อรอให้เกมวาร์ป (Teleport) ผู้เล่นไปที่ด่าน
    while true do
        task.wait(1)
    end
end

-- ถ้าย้ายด่านมาแล้ว ไม่ใช่ด่านหลัก (เกมเพลย์) ให้หยุดทำงานส่วนที่เหลือ
if game.PlaceId ~= 124069847780670 then return api end

-- รอโหลด UI และโฟลเดอร์ต่างๆ ในเกมเพลย์
local towers = bytenet.Towers
local mapinfo = replicatedstorage:WaitForChild("RoundInfo", 10)
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui", 10)
local roundresultui = PlayerGui:WaitForChild("GameUI"):WaitForChild("RoundResult")

local ostime = os.time
local taskwait = task.wait
local env = getgenv()

env.StratName = "Strat"

env.timer = 0 -- seconds
env.lasttime = ostime()
env.waveinfo = 1
env.isroundover = false

env.totalplacedtowers = 0
env.firsttower = 1
env.macro_started = false

env.destroyui = false

local window = library:CreateWindow({
    Title = "Shitty X",
    Size = UDim2.new(0, 350, 0, 370),
    Position = UDim2.new(0.5, 0, 0, 70),
    NoResize = false
})

window:Center()

local logtab = window:CreateTab({
    Name = "Macro Player",
    Visible = true
})

local filename = logtab:Label({
    Text = "StratName: " .. env.StratName
})

local logstab = window:CreateTab({
    Name = "Logs",
    Visible = true
})

local loglabel = logtab:Label({
    Label = "Last Log: Voting"
})

local row = logstab:Row()

logstab:Separator({
    Text = "Logs:"
})

local logs = logstab:Console({
    Text = "",
    ReadOnly = true,
    LineNumbers = false,
    Border = false,
    Fill = true,
    Enabled = true,
    AutoScroll = true,
    RichText = true,
    MaxLines = 200
})

function updatelog(text: string)
    setthreadidentity(7)
    logs:AppendText(DateTime.now():FormatLocalTime("HH:mm:ss", "en-us") .. ":", text)
    loglabel:SetText("Last Log: " .. text)
end

window:ShowTab(logtab)
updatelog("Waiting for game to start...")

function waitTime(time, wave)
    while env.waveinfo < wave and not env.isroundover do
        taskwait(0.05)
    end
        
    while env.timer < time and not env.isroundover do
        taskwait(0.05)
    end
        
    return not env.isroundover
end

function api:Loop(func)
    if game.PlaceId ~= 124069847780670 then return end 
    
    while taskwait(0.03) do             
        func()
    end
end

function api:Start()
    if env.macro_started then return end
    env.macro_started = true

    -- หน่วงเวลา 2 วินาทีเพื่อให้ชัวร์ว่าแมพโหลดโมเดลต่างๆ เสร็จแล้ว
    taskwait(2)

    bytenet.Timescale.SetTimescale.send(2)

    env.waveinfo = mapinfo:GetAttribute("Wave") or 1
    env.timer = 0
    
    mapinfo:GetAttributeChangedSignal("Wave"):Connect(function()
        env.waveinfo = mapinfo:GetAttribute("Wave")
    end)

    roundresultui:GetPropertyChangedSignal("Visible"):Connect(function()
        env.isroundover = roundresultui.Visible
    end)
    
    updatelog("Game Started")
        
    task.spawn(function()
        env.lasttime = ostime()
        while true do
            if env.lasttime then
                env.timer = (ostime() - env.lasttime) * 2
            end
            taskwait(0.25)
        end
    end)
end

function api:Difficulty(diff: string)
    updatelog(`Voted difficulty {diff}`)
    bytenet.DifficultyVote.Vote.send(diff)
    
    while #mapinfo:GetAttribute("Difficulty") == 0 do taskwait(0.05) end 
    
    env.lasttime = ostime()
    env.timer = 0
    env.waveinfo = 1
    
    taskwait(0.1)
end

function api:Ready(time: number, wave: number)
    if waitTime(time, wave) then 
        updatelog("Sent ready vote") 
        bytenet.ReadyVote.Vote.send(true) 
    end
end

function api:Skip(time: number, wave: number)
    if waitTime(time, wave) then 
        updatelog(`Skipping Wave {wave}`) 
        replicatedstorage:WaitForChild("ByteNetReliable"):FireServer(buffer.fromstring("\148\001")) 
    end
end

function api:AutoSkip(enable: number, time: number, wave: number)
    if waitTime(time, wave) then 
        updatelog(`AutoSkip set to {tostring(enable)}`) 
        bytenet.SkipWave.ToggleAutoSkip.send(enable) 
    end
end

function api:Place(tower: string, position: Vector3, time: number, wave: number)
    if waitTime(time, wave) then    
        env.totalplacedtowers = env.totalplacedtowers + 1
        
        updatelog(`Placed Tower {tower}`)
        towers.PlaceTower.invoke({["Position"] = position, ["Rotation"] = 0, ["TowerID"] = tower})
    end
end

function api:Upgrade(tower: number, time: number, wave: number)
    if waitTime(time, wave) then
        updatelog(`Upgraded Tower {tower}`)
        
        local realindex = env.firsttower + (tower - 1)
        towers.UpgradeTower.invoke(realindex)
    end
end

function api:SetTarget(tower: number, target: string, time: number, wave: number)
    if waitTime(time, wave) then
        updatelog(`Changed Tower {tower} Target to {target} `)
    
        local realindex = env.firsttower + (tower - 1)
        towers.SetTargetMode.send({["UID"] = (realindex), ["TargetMode"] = target})
    end
end

function api:Sell(tower: number, time: number, wave: number)
    if waitTime(time, wave) then
        updatelog(`Sold Tower {tower}`) 
        
        local realindex = env.firsttower + (tower - 1)
        towers.SellTower.invoke(realindex)
    end
end

function api:PlayAgain()
    -- รอจนกว่าเกมจะจบ (หน้าต่างสรุปผลขึ้น)
    while not env.isroundover do taskwait(0.1) end
    
    updatelog("Match ended. Returning to lobby in 4 seconds...")
    taskwait(4) -- รอรับของรางวัลให้เสร็จสมบูรณ์
    
    -- วาร์ปกลับล็อบบี้เพื่อรีเซ็ตเซิร์ฟเวอร์และเริ่มรอบใหม่แบบคลีนๆ
    local TeleportService = game:GetService("TeleportService")
    TeleportService:Teleport(98936097545088)
    
    -- หยุดการทำงานของสคริปต์ระหว่างรอวาร์ป
    while true do taskwait(1) end
end

return api
